In React components, code reuse is primarily achieved through composition rather than inheritance.
Read about the Components specs and lifecycle in React. RN comes from ReactJS, they have a lot of things in common and understanding things like componentDidMount() or componentWillMount() will help you. 

The Component Lifecycle
Each component has several “lifecycle methods” that you can override to run code at particular times in the process. You can use this lifecycle diagram as a cheat sheet. In the list below, commonly used lifecycle methods are marked as bold. The rest of them exist for relatively rare use cases.

**Mounting**
These methods are called in the following order when an instance of a component is being created and inserted into the DOM:

constructor()
static getDerivedStateFromProps()
render()
componentDidMount()

--The other unusual thing in this code example is <View><Text>Hello world!</Text></View>. This is JSX - a syntax for embedding XML within JavaScript
--What are Components?
A new Component. When you're building a React Native app, you'll be making new components a lot. Anything you see on the screen is some sort of component. A component can be pretty simple - the only thing that's required is a render function which returns some JSX to render.

**** How Does React Native Work?
          The idea of writing mobile applications in JavaScript feels a little odd. How is it possible
          to use React in a mobile environment? In order to understand the technical underpinnings
          of React Native, first we’ll need to recall one of React’s features, the Virtual DOM.
          In React, the Virtual DOM acts as a layer between the developer’s description of how
          things ought to look, and the work done to actually render your application onto the page.
          To render interactive user interfaces in a browser, developers must edit the browser’s
          DOM, or Document Object Model. This is an expensive step, and excessive writes to the
          DOM have a significant impact on performance. Rather than directly render changes on
          the page, React computes the necessary changes by using an in-memory version of the
          DOM, and rerenders the minimal amount necessary.

          This is all possible because of the “bridge,” which provides React with an interface into
          the host platform’s native UI elements. React components return markup from their
          render function, which describes how they should look. With React for the Web, this
          translates directly to the browser’s DOM. For React Native, this markup is translated to
          suit the host platform, so a <View> might become an iOS-specific UIView.
          React Native currently supports iOS and Android. Because of the abstraction layer
          provided by the Virtual DOM, React Native could target other platforms, too — someone
          just needs to write the bridge.


******************* Difference between react-native init demoproject and create-react-native-app ******************************

Using create-react-native-app creates a project that is bootstrapped with Expo.
Whereas react-native init creates a project that is just react-native,

React Native init:

Advantages:

You can add native modules written in Java/Objective-C (probably the only but the strongest one)
Disadvantages:

Needs Android Studio and XCode to run the projects
You can't develop for iOS without having a mac
Device has to be connected via USB to use it for testing
Fonts need to be imported manually in XCode
If you want to share the app you need to send the whole .apk / .ipa file
Does not provide JS APIs out of the box, e.g. Push-Notifications, Asset Manager, they need to be manually installed and linked with npm for example
Setting up a working project properly (inlcuding device configuration) is rather complicated and can take time
Expo

Advantages:

Setting up a project is easy and can be done in minutes
You (and other people) can open the project while you're working on it
Sharing the app is easy (via QR-code or link), you don't have to send the whole .apk or .ipa file
No build necessary to run the app
Integrates some basic libraries in a standard project (Push Notifications, Asset Manager,...)
You can eject it to ExpoKit and integrate native code continuing using some of the Expo features, but not all of them
Expo can build .apk and .ipa files (distribution to stores possible with Expo)
Disadvantages:

You can't add native modules (probably a gamechanger for some)
You can't use libraries that use native code in Objective-C/Java
The standard Hello World app is about 25MB big (because of the integrated libraries)
If you want to use: FaceDetector, ARKit o Payments you need to eject it to ExpoKit
Ejecting it to ExpoKit has a trade-off of features of Expo, e.g. you cannot share via QR code
When ejecting to ExpoKit you are limited to the react native version that is supported by ExpoKit at that point in time
Debugging in ExpoKit (with native modules) is a lot more complicated, since it mixes two languages and different libraries (no official Expo support anymore)


